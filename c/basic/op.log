+-*/% ++ --
/ 
5/2 = 2
5.0/2  5/2.0   = 2.5

%
5%2 = 1
5.0%2  FFFFFFFF

++ -- 自增/减 
i++ ++i =>  i = i+1
i-- --i =>  i = i-1
规则：变量在前先取变量，符号在前先进行自增/减

int i,j;
i = 4;
j = i++;	=>   j = i; i = i+1   => j = 4,i = 5
i = ++i;	=>   i = i+1; j = i;  => i = 5,j = 5;

int m = 2,n = 3,i;
i = m++ - --n; 	=>  n=n-1; i = m-n; m=m+1
i = --m + --n;  ??
i = ++m + n--;  ??

-----------------------------------------------
< <= > >= == !=     结论：逻辑值

int i = 1 ,j = 2;
i == j    	  0
i < j		  1
i >= j		  0
i != j		  1
++i == j	  1

-------------------------------------------------
! && || 

int i = 0,j = 123;
i	0
!i	1
j 	1
!j	0

op1  &&  op2
1         1        1
1         0	 	   0
0		  1		   0
0		  0		   0

op1  ||  op2
1         1        1
1         0        1
0         1        1
0         0        0

int i = 1,j = 3;

i > 0 && j < 10		1
i+5  &&  j > 100	0

i > 0 || j < 10		1
i+5  || j > 100		1

&& || 特点：短路特性：&&当左侧表达式为真时才去检查右侧，||当左侧表达式为假时才去检查右侧。

eg:
int a = 1,b = 2,c = 3,d = 4,m=1,n=1;
(m = a > b) && (n = c > d);
printf("m = %d,n = %d\n",m,n);
--------------------------------------------------------

= += -= *= /=
a += b   =>   a = a + b
a -= c+d  => a = a-(c+d)

int i = 3,j;
j = i;


int a = 6;		
a += a -= a *= a /=6;		=> a = 0
	  
-----------------------------------------------------
op1 ? op2 : op3 三目运算符   
op1为真则执行op2,否则执行op3

int i = 3,j = 5,t;
t = i > j ? i : j;

if(i > j)
	t = i;
else
	t =j;

----------------------------------------------

int i = 1,j = 2,t;

t = i++,j++,i+j;
t = i++,--j,i+j,400;

----------------------------------------
(type)

float f = 3.9;
int i;

i = (int)f;
printf("i = %d",i);
printf("f = %f",f);









































